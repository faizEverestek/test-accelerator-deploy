version: 2.1
orbs:
  aws-cli: circleci/aws-cli@2.0.3
  aws-ecs: circleci/aws-ecs@0.0.8

# Define the executors
executors:
  java-executor:
    docker:
      - image: cimg/openjdk:21.0.2  # Use OpenJDK 21 Docker image for Java-based builds

# Define pipeline parameters, change default values accordingly.
parameters:
  jar-file-name:
    default: petInsurance-1.0.0.war
    description: Name of the generated JAR/WAR file of the project.
    type: string
  jar-file-path:
    default: target/petInsurance-1.0.0.war
    description: Path where the generated JAR/WAR file is located.
    type: string
  aws-ecr-repo:
    default: ecr-repo-1
    description: Name of the Amazon ECR repository, where the docker image with be pushed after successful build.
    type: string
  docker-image-version:
    default: 1.0.0
    description: Latest version of the Docker image that will be used in the image tag.
    type: string
  task-definition-family:
    default: family-1
    description: Name of the ECS task definition family.
    type: string
  ecs-cluster-name:
    default: cluster-1
    description: Name or ARN of the ECS cluster hosting the service.
    type: string
  ecs-service-name:
    default: service-1
    description: Name of the ECS service to update.
    type: string
  ecs-service-container-name:
    default: container-1
    description: Name of the container within the task definition.
    type: string
  aws-access-key-id:
    default: AWS_ACCESS_KEY_ID
    description: The access key id of the AWS account, passed as ENV variable.
    type: string
  aws-secret-access-key:
    default: AWS_SECRET_ACCESS_KEY
    description: The secret access key id of the AWS account, passed as ENV variable.
    type: string
  region:
    default: AWS_DEFAULT_REGION
    description: The default region of the AWS account, passed as ENV variable.
    type: string
  aws-account-id:
    default: AWS_ACCOUNT_ID
    description: AWS account ID of the account which is used for deployment.
    type: string

# Define jobs
jobs:
  build:
    executor: java-executor
    steps:
      - checkout  # Checkout the source code from the repository

      - run:
          name: Set Execute Permission for Maven Wrapper
          command: chmod +x ./mvnw  # Ensure Maven wrapper script is executable

      - run:
          name: Resolve dependencies
          command: ./mvnw dependency:resolve  # Download and cache project dependencies

      - run:
          name: Build and Test
          command: ./mvnw clean install # Build, run tests, and generate test coverage reports

          # Store test coverage reports
      - store_artifacts:
          path: target/site/jacoco
          destination: jacoco-test-reports/

      # Store static analysis reports
      - store_artifacts:
          path: target/checkstyle-result.xml
          destination: quality-checks/checkstyle
      - store_artifacts:
          path: target/pmd.xml
          destination: quality-checks/pmd
      - store_artifacts:
          path: target/cpd.xml
          destination: quality-checks/cpd
      - store_artifacts:
          path: target/spotbugs.html
          destination: quality-checks/spotbugs

      - persist_to_workspace:
          root: .
          paths:
            - <<pipeline.parameters.jar-file-path>>  # Save the built JAR file for later jobs

  package:
    executor: java-executor
    working_directory: ~/workspace  # Define working directory for this job

    steps:
      - checkout  # Checkout the source code

      - attach_workspace:
          at: .  # Attach the workspace from the build job

      - setup_remote_docker  # Enable remote Docker support

      - run:
          name: Copy WAR to Docker build context
          command: |
            cp <<pipeline.parameters.jar-file-path>> .

      - run:
          name: Construct ECR Account URL
          command: |
            export ECR_URL="$<<pipeline.parameters.aws-account-id>>.dkr.ecr.$<<pipeline.parameters.region>>.amazonaws.com"
            echo "ECR_URL=$ECR_URL"
            echo "export ECR_URL=$ECR_URL" >> $BASH_ENV
            # Save the ECR_URL for the publish job
            echo $ECR_URL > ecr_url.txt 

      - run:
          name: Build and save Docker Image
          command: |
            export TIMESTAMP=$(date +"%Y%m%d%H%M%S")  # Generate a timestamp for the Docker image tag
            export TAG=<<pipeline.parameters.docker-image-version>>-${TIMESTAMP}_SNAPSHOT
            export WAR_BASENAME=$(basename <<pipeline.parameters.jar-file-path>>)
            
            # Build Docker image using parameters
            docker build \
              --build-arg JAR_FILE_PATH=${WAR_BASENAME} \
              --build-arg JAR_FILE_NAME=<<pipeline.parameters.jar-file-name>> \
              -t <<pipeline.parameters.aws-ecr-repo>>:${TAG} .
            
            # Save Docker image to a tar file
            docker save -o my-app.tar <<pipeline.parameters.aws-ecr-repo>>:${TAG}
            
            # Save the tag information for the publish job
            echo $TAG > tag.txt

      - persist_to_workspace:
          root: /home/circleci/workspace
          paths:
            - tag.txt  # Save the image tag information for the next job
            - ecr_url.txt # Save the ECR URL for the next job
            - my-app.tar  # Save the built Docker image

  publish:
    executor: java-executor
    steps:
      - checkout  # Checkout the source code
      - attach_workspace:
          at: /home/circleci/workspace  # Attach the workspace from the package job
      - setup_remote_docker  # Enable remote Docker support

      - aws-cli/setup:
          aws-access-key-id: <<pipeline.parameters.aws-access-key-id>>
          aws-region: <<pipeline.parameters.region>>
          aws-secret-access-key: <<pipeline.parameters.aws-secret-access-key>>

      - run:
          name: Export Metadata
          command: |
            ls
            export TAG="$(cat /home/circleci/workspace/tag.txt)"  # Read the image tag from the file
            echo "TAG='${TAG}'"
            echo "export TAG='${TAG}'" >> $BASH_ENV  # Persist the tag as an environment variable
            
            export ECR_URL="$(cat /home/circleci/workspace/ecr_url.txt)"  # Read the ECR_URL from the file
            echo "ECR_URL='${ECR_URL}'"
            echo "export ECR_URL='${ECR_URL}'" >> $BASH_ENV  # Persist the ECR_URL as an environment variable

      # Load the previously build docker image
      - run:
          name: Load Docker image
          command: docker load -i /home/circleci/workspace/my-app.tar  # Load the saved Docker image

      - run:
          name: Ensure ECR Repository Exists
          command: |
            REPO_NAME=<< pipeline.parameters.aws-ecr-repo >>
            ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
            REGION=$<< pipeline.parameters.region >>
            
            echo "Checking if ECR repo $REPO_NAME exists..."
            if ! aws ecr describe-repositories --repository-names "$REPO_NAME" > /dev/null 2>&1; then
              echo "ECR repo $REPO_NAME does not exist. Creating it now..."
              aws ecr create-repository \
                --repository-name "$REPO_NAME" \
                --image-scanning-configuration scanOnPush=true \
                --region "$REGION"
              echo "Waiting for ECR repo $REPO_NAME to become available..."
              for i in {1..10}; do
                if aws ecr describe-repositories --repository-names "$REPO_NAME" > /dev/null 2>&1; then
                  echo "ECR repo $REPO_NAME is now available."
                  break
                fi
                echo "Waiting... ($i/10)"
                sleep 3
              done
            else
              echo "ECR repo $REPO_NAME already exists."
            fi

      # Authenticate with AWS ECR.
      - run:
          name: Login to ECR
          command: |
            echo "${ECR_URL}"
            aws ecr get-login-password --region $<<pipeline.parameters.region>> | docker login --username AWS --password-stdin $ECR_URL

      # Create a new tag for docker image to push into ECR
      - run:
          name: Tag Docker Image
          command: |
            docker tag <<pipeline.parameters.aws-ecr-repo>>:${TAG} $ECR_URL/<<pipeline.parameters.aws-ecr-repo>>:${TAG}

      # Push docker image to ECR
      - run:
          name: Push Docker Image to AWS ECR
          command: |
            echo "Pushing image: $TAG"
            docker push $ECR_URL/<<pipeline.parameters.aws-ecr-repo>>:$TAG  # Push the image to AWS ECR

      - persist_to_workspace:
          root: /home/circleci/workspace
          paths:
            - tag.txt  # Save the image tag information for the next job
            - ecr_url.txt # Save the ECR URL for the next job
  deploy:
    executor: java-executor
    working_directory: ~/workspace
    steps:
      - checkout
      - attach_workspace:
          at: ~/workspace
      - run:
          name: Export Metadata
          command: |
            export TAG="$(cat ~/workspace/tag.txt)"
            echo "TAG='${TAG}'"
            echo "export TAG='${TAG}'" >> $BASH_ENV
            
            export ECR_URL="$(cat /home/circleci/workspace/ecr_url.txt)"
            echo "ECR_URL='${ECR_URL}'"
            echo "export ECR_URL='${ECR_URL}'" >> $BASH_ENV

      - aws-cli/setup:
          aws-access-key-id: <<pipeline.parameters.aws-access-key-id>>
          aws-region: <<pipeline.parameters.region>>
          aws-secret-access-key: <<pipeline.parameters.aws-secret-access-key>>

      - run:
          name: Create ECS Cluster if not exists
          command: |
            CLUSTER_NAME=<< pipeline.parameters.ecs-cluster-name >>

            if aws ecs describe-clusters --clusters $CLUSTER_NAME | grep -q '"status": "ACTIVE"'; then
              echo "Cluster $CLUSTER_NAME already exists"
            else
              echo "Creating ECS Cluster: $CLUSTER_NAME"
              aws ecs create-cluster --cluster-name $CLUSTER_NAME
            fi

      - run:
          name: Register ECS Task Definition if not exists
          command: |
            FAMILY_NAME=<< pipeline.parameters.task-definition-family >>
            CONTAINER_NAME=<< pipeline.parameters.ecs-service-container-name >>
            IMAGE_URL=$ECR_URL/<<pipeline.parameters.aws-ecr-repo>>:${TAG}

            EXISTING=$(aws ecs describe-task-definition --task-definition $FAMILY_NAME 2>/dev/null || true)

            if echo "$EXISTING" | grep -q 'taskDefinition'; then
              echo "Task definition $FAMILY_NAME already exists"
            else
              echo "Registering new task definition for $FAMILY_NAME"
              aws ecs register-task-definition \
                --family $FAMILY_NAME \
                --network-mode awsvpc \
                --requires-compatibilities FARGATE \
                --cpu "1024" \
                --memory "3072" \
                --execution-role-arn arn:aws:iam::$(aws sts get-caller-identity --query Account --output text):role/ecsTaskExecutionRole \
                --container-definitions "[
                  {
                    \"name\": \"$CONTAINER_NAME\",
                    \"image\": \"$IMAGE_URL\",
                    \"essential\": true,
                    \"portMappings\": [
                      {
                        \"containerPort\": 8080,
                        \"hostPort\": 8080,
                        \"protocol\": \"tcp\",
                        \"appProtocol\": \"http\"
                      }
                    ]
                  }
                ]"
            fi

      - run:
          name: Create ECS Service if not exists
          command: |
            CLUSTER_NAME=<< pipeline.parameters.ecs-cluster-name >>
            SERVICE_NAME=<< pipeline.parameters.ecs-service-name >>
            FAMILY_NAME=<< pipeline.parameters.task-definition-family >>
            SG_NAME="${SERVICE_NAME}-sg"

            VPC_ID=$(aws ec2 describe-vpcs --query "Vpcs[0].VpcId" --output text)

            echo "Checking if security group '$SG_NAME' exists in VPC '$VPC_ID'..."
            SG_ID=$(aws ec2 describe-security-groups \
              --filters Name=group-name,Values=$SG_NAME Name=vpc-id,Values=$VPC_ID \
              --query "SecurityGroups[0].GroupId" \
              --output text 2>/dev/null)

            if [ "$SG_ID" == "None" ] || [ -z "$SG_ID" ]; then
              echo "Security group not found. Creating it now..."
              SG_ID=$(aws ec2 create-security-group \
                --group-name "$SG_NAME" \
                --description "Allow port 8080 access for ECS service" \
                --vpc-id $VPC_ID \
                --query "GroupId" \
                --output text)

              echo "Authorizing inbound access to port 8080..."
              aws ec2 authorize-security-group-ingress \
                --group-id $SG_ID \
                --protocol tcp \
                --port 8080 \
                --cidr 0.0.0.0/0
            else
              echo "Security group '$SG_NAME' already exists with ID $SG_ID"
            fi

            echo "Finding default subnet for ECS networking..."
            SUBNET_ID=$(aws ec2 describe-subnets \
              --filters "Name=default-for-az,Values=true" \
              --query "Subnets[0].SubnetId" \
              --output text)

            echo "Checking if ECS service '$SERVICE_NAME' already exists in cluster '$CLUSTER_NAME'..."
            SERVICE_EXISTS=$(aws ecs describe-services --cluster $CLUSTER_NAME --services $SERVICE_NAME 2>/dev/null || true)

            if echo "$SERVICE_EXISTS" | grep -q '"status": "ACTIVE"'; then
              echo "Service $SERVICE_NAME already exists"
            else
              echo "Creating service $SERVICE_NAME in cluster $CLUSTER_NAME"
              aws ecs create-service \
                --cluster $CLUSTER_NAME \
                --service-name $SERVICE_NAME \
                --task-definition $FAMILY_NAME \
                --desired-count 1 \
                --launch-type FARGATE \
                --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_ID],securityGroups=[$SG_ID],assignPublicIp=ENABLED}"
            fi

      - run:
          name: Wait for ECS Service to become ACTIVE
          command: |
            CLUSTER_NAME=<< pipeline.parameters.ecs-cluster-name >>
            SERVICE_NAME=<< pipeline.parameters.ecs-service-name >>

            echo "Waiting for ECS service $SERVICE_NAME to become ACTIVE..."

            for i in {1..12}; do
              STATUS=$(aws ecs describe-services --cluster $CLUSTER_NAME --services $SERVICE_NAME \
                --query "services[0].status" --output text)

              echo "Current status: $STATUS"
              if [ "$STATUS" = "ACTIVE" ]; then
                echo "Service is now ACTIVE"
                break
              fi

              echo "Not ready yet... waiting 5s"
              sleep 5
            done

            if [ "$STATUS" != "ACTIVE" ]; then
              echo "Timed out waiting for ECS service to become ACTIVE"
              exit 1
            fi

      - aws-ecs/update-service:
          family: << pipeline.parameters.task-definition-family >>
          cluster-name: << pipeline.parameters.ecs-cluster-name >>
          service-name: << pipeline.parameters.ecs-service-name >>
          container-image-name-updates: container=<< pipeline.parameters.ecs-service-container-name >>,tag=${TAG}

# Define the workflow
workflows:
  version: 2
  build:
    jobs:
      - build:
          name: build  # Run the build job first
      - package:
          name: package
          requires:
            - build  # Ensure the package job runs only after the build is complete
      - publish:
          name: publish
          requires:
            - package  # Ensure the publishing job runs only after the package is complete
      - deploy:
          name: deploy
          requires:
            - publish
#          filters:
#            branches:
#              only:
#                - development # Add your branch name